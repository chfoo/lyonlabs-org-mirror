#include <stdio.h>
#include <unistd.h>
#include <syslog.h>
#include <errno.h>

#include "qpacket.h"
#include "qio.h"
#include "qparse.h"

static unsigned char ucPacketBuf[1024];
static unsigned char nCliSeq;     /* The client should be sending this packet*/
static unsigned char nSerSeq;     /* The server is sending this packet */
static unsigned char nCliFreeSeq; /* The client may forget about this packet */
static unsigned char nSerFreeSeq; /* The server may forget about this packet */
static unsigned char nProtoMinor; /* The protocol minor version */
static unsigned char nProtoMajor; /* The protocol major version */
static int nFoundChrs;
static int nCork = 0;             /* The packet protocol must queue transmitted packets */
static int nReadFD = 0;           /* This is the file descriptor to read from */
static int nWriteFD = 0;          /* This is the file descriptor to write to */
static int fProtocolStarted;      /* This tracks if the protocol is running or not */
static int fInFrame;              /* This tracks if we are in frame or not */

void qpp_cork(void) {
  nCork = 2;
}

void qpp_uncork(void) {
  nCork = 0;
}

/*Compute CRC for a packet.  The packet data including sequence numbers and
  the packet type must be present.  The framing characters and CRC bytes should
  not be present at all. */
unsigned short compute_CRC(unsigned char *pszPacketDataBuf, int nPacketLen){

  int nByteCounter;
  int nBitCounter;
  unsigned short nTempCRC;
  unsigned char nCRCHigh;
  unsigned char nCRCLow;

  nCRCHigh = 0;
  nCRCLow  = 0;

  for (nByteCounter = 0; nByteCounter < nPacketLen; nByteCounter++){
    /*Set a counter to 8 times*/
    nTempCRC = (nCRCLow << 8);
    for (nBitCounter = 0; nBitCounter < 8; nBitCounter++) {
      /*Move low bit of new byte to C, high bit of new byte becomes 0
        Move C into low bit of A, Move high bit of A into C
	Mask off all of A except new bit */
      nTempCRC = ((nTempCRC & 0xFF00) | ((pszPacketDataBuf[nByteCounter] & (1 << nBitCounter)) >> nBitCounter));
      /*Xor CRChigh into A*/
      nTempCRC = nTempCRC ^ nCRCHigh;
      /*Move low bit of CRClow into C, high bit of CRC low becomes 0
	Move C into high bit of A, move low bit of A into C
	If C is not set, not ready to xor in CRC polynomial */
      if (nTempCRC & 1) {
	nTempCRC = nTempCRC >> 1;
	/*Get CRClow
	  Xor in polylow
	  Store CRClow */
	nTempCRC = ((nTempCRC & 0x00FF) | (((nTempCRC >> 8) ^ 0xA0) << 8));
	/*Xor in polyhigh
	  Store CRChigh */
	nTempCRC = nTempCRC ^ 0x01;
	nCRCHigh = nTempCRC & 0x00FF;
      } else {
	nTempCRC = nTempCRC >> 1;
	nCRCHigh = nTempCRC & 0x00FF;
      }
    }
    nCRCLow = nTempCRC >> 8;
  }
  return ((nCRCHigh << 8) | nCRCLow);
}

/*Takes some data and sends it through the packet protocol.  The
  packet type byte must be present, but the sequence numbers and
  framing bytes will be generated by this function. */
void transmit_packet(unsigned char *pPacketBuf, int nPacketLen) {
  unsigned char szTempBuf[1024];
  unsigned short nCRC;

  szTempBuf[0] = 0x5A;

  memcpy(&szTempBuf[7], pPacketBuf, nPacketLen);
  szTempBuf[5] = nSerSeq;
  szTempBuf[6] = nCliFreeSeq;
  nCRC = compute_CRC(&szTempBuf[5], nPacketLen+2);
  szTempBuf[1] = (nCRC & 0x00F0) | 0x01;
  szTempBuf[2] = (nCRC & 0x000F) | 0x40;
  szTempBuf[3] = ((nCRC >> 8)& 0x00F0) | 0x01;
  szTempBuf[4] = ((nCRC >> 8)& 0x000F) | 0x40;
  szTempBuf[nPacketLen + 7] = 0x0D;

	if ((nCork == 1) && (szTempBuf[7] == 0x20)){
		return;
  }

	if ((nCork == 2) && (szTempBuf[7] == 0x20) && (szTempBuf[8] == 'S') && (szTempBuf[9] == 'S')) {
	  nCork = 1;
	}

  write(nWriteFD, szTempBuf, nPacketLen + 8);
}

/* Takes back a command that crashes the client */
void qpacket_back(void) {
   nSerSeq--;
   if (nSerSeq < 0x10) {
      nSerSeq = 0x7F;
   }
}

/* This transmits a layer 3 command to the client.  This means
   that these commands will affect the user experience somehow.
   This function has to be here because commands are transmitted
   differently that layer 2 response packets. */
void transmit_command(unsigned char *pCommand, unsigned char *pData, int nDataLen){

  unsigned char TempCommandBuf[1024];

	memset(TempCommandBuf, 0, 1024);

	TempCommandBuf[0] = 0x20;
  TempCommandBuf[1] = pCommand[0];
  TempCommandBuf[2] = pCommand[1];

  nSerSeq++;
  if (nSerSeq == 0x80) {
    nSerSeq = 0x10;
  }

  if (pData != NULL) {
    memcpy(&TempCommandBuf[3], pData, nDataLen);
  }

	syslog(LOG_INFO, "Sending %d bytes '%s'", nDataLen + 3, TempCommandBuf);
	transmit_packet(TempCommandBuf, nDataLen + 3);
}

/* Once a packet is found to be accurately framed, then it
   is sent to this function to be checked for accuracy and
	 processed as appropriate.*/
void qpp_interpretpacket(unsigned char *pPacketBuf, int nPacketLen) {
  unsigned short nRecCRC;
  unsigned short nCalcCRC;
  unsigned char  nRecSerFreeSeq;
  unsigned char  nRecCliSeq;
  unsigned char  nType;

  nRecCRC = ((((pPacketBuf[3] & 0xF0) | (pPacketBuf[4] & 0x0F)) << 8) |
	     (((pPacketBuf[1] & 0xF0) | (pPacketBuf[2] & 0x0F))));
  nCalcCRC = compute_CRC(&pPacketBuf[5], nPacketLen-6);
  nRecCliSeq = pPacketBuf[5];
  nRecSerFreeSeq = pPacketBuf[6];
  nType = pPacketBuf[7];

  if (pPacketBuf[0] != 0x5A) {
    return;
  }
  if (pPacketBuf[nPacketLen-1] != 0x0D) {
    return;
  }
  if (nRecCRC != nCalcCRC) {
    return;
  }
  switch (nType) {
  case 0x21:
	  syslog(LOG_INFO, "Client packet retransmission queue full.");
		transmit_packet("\x22", 1);
    break;
  case 0x22:
    break;
  case 0x23:
	  if (fProtocolStarted) {
		  syslog(LOG_ERR, "Client reports bad checksum.");
    } else {
		  nProtoMajor = pPacketBuf[9];
			nProtoMinor = pPacketBuf[8];
		  syslog(LOG_INFO, "Protocol started.  Client using %d.%d", nProtoMajor, nProtoMinor);
    }
    transmit_packet("\x24",1);
    return;
  case 0x24:
    break;
  case 0x25:
	  syslog(LOG_ERR, "Packet sequence error detected.");
    break;
  case 0x26:
	  syslog(LOG_INFO, "Keepalive packet received.");
    transmit_packet("\x24",1);
    return;
  }

  if (nRecCliSeq != nCliSeq) {
    return;
  }

  /* Allow the client to free a packet and get ready to expect the next one */
  nCliFreeSeq = nCliSeq;
  nCliSeq++;
  if (nCliSeq == 0x80) {
    nCliSeq = 0x10;
  }

  /* We should really free stored packets here, but we don't store them yet */

  qparse_handlepacket(&pPacketBuf[8], nPacketLen-9);
}

/* This searches the incoming bytestream for a properly framed packet.  This is
   signaled by a 0x5A byte at the beginning and a 0x0D byte at the end. */
int qpp_receivepacket(void) {

   unsigned char ucReadBuf[1024];
   int nGotChrs;
   int nCounter;

   nGotChrs = read(nReadFD, ucReadBuf, 1024);
   if (nGotChrs == -1) {
      syslog(LOG_NOTICE, "Read error encountered: %d", errno);
   }
   if (nGotChrs == 0) {
      syslog(LOG_NOTICE, "User has disconnected from server");
      exit(0);
   }
   for (nCounter = 0; nCounter < nGotChrs; nCounter++) {
      ucPacketBuf[nFoundChrs] = ucReadBuf[nCounter];
      if (ucPacketBuf[0] == 0x5A) {
         nFoundChrs++;
         fInFrame = 1;
      } else {
         nFoundChrs = 0;
         if (fInFrame) {
            syslog(LOG_ERR, "Frame slip detected.");
            fInFrame = 0;
         }
         continue;
      }
      if (nFoundChrs > 128) {
         return 0;
      }
      if (ucReadBuf[nCounter] == 0x0D) {
         qpp_interpretpacket(ucPacketBuf, nFoundChrs);
         if (nCounter < nGotChrs) {
            ucPacketBuf[0] = 0;
            nFoundChrs = 0;
         } else {
            return 1;
         }
      }
   }
   return 0;
}

/*This function initializes QPP.  It must be called before the packet handlers
  can be called.*/
void qpp_init(int nNewReadFD, int nNewWriteFD) {

  nCliSeq = 0x10;
  nSerSeq = 0x7F;
  nCliFreeSeq = 0x7F;
  nSerFreeSeq = 0x7F;

  nReadFD = nNewReadFD;
  nWriteFD = nNewWriteFD;

   ucPacketBuf[0] = 0;
   nFoundChrs = 0;
   fProtocolStarted = 0;
   fInFrame = 0;

   qio_register_fd(nReadFD, ssPacket);
}
